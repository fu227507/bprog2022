GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kanonh/bprog2022/.ghci
2022-05-19 15:41:20.167030709
>>> 1+3
4
2022-05-19 15:54:15.596420509
>>> 1+2*4
9
2022-05-19 15:54:32.849025945
>>> 2/6
0.3333333333333333
2022-05-19 15:54:59.494486141
>>> 4/10
0.4
2022-05-19 15:55:17.225703798
>>> 2/5
0.4
2022-05-19 15:55:24.209553862
>>> 5-4-8+1
-6
2022-05-19 15:55:37.332137957
>>> -6+6
0
2022-05-19 15:55:51.787131664
>>> 1+2+3+4+5+6+7+8+9+10
55
2022-05-19 15:56:29.053715161
>>> sqrt 4
2.0
2022-05-19 15:59:00.208653864
>>> sqrt 99
9.9498743710662
2022-05-19 15:59:16.683459896
>>> sqrt 2
1.4142135623730951
2022-05-19 15:59:55.134184948
>>> double 3

<interactive>:12:1: error: Variable not in scope: double :: t0 -> t
2022-05-19 16:02:31.075881795
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kanonh/bprog2022/.ghci
2022-05-26 15:02:05.514404928
>>> maxBound :: Int
9223372036854775807
2022-05-26 15:03:50.039050365
>>> 2 ^ 63 - 1
9223372036854775807
2022-05-26 15:05:15.288642062
>>> minBound :: Int
-9223372036854775808
2022-05-26 15:05:36.414844443
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kanonh/bprog2022/.ghci
2022-05-26 15:26:20.630013041
>>> :e src/first.hs
catn: src/first.hs: openFile: does not exist (No such file or directory)
2022-05-26 15:49:02.512203135
>>> :l src/first.hs

<no location info>: error: can't find file: src/first.hs
Failed, no modules loaded.
2022-05-26 15:49:02.551012377
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x

<no location info>: error: can't find file: src/first.hs
Failed, no modules loaded.
2022-05-26 15:49:38.962496962
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-05-26 15:49:39.024426327
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
Ok, one module loaded.
2022-05-26 15:55:55.110723317
>>> double 3
6
2022-05-26 15:56:18.495956151
>>> double 1 + 3
5
2022-05-26 15:56:50.720335629
>>> double (1 + 3)
8
2022-05-26 15:57:19.415187139
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kanonh/bprog2022/.ghci
2022-06-09 14:55:04.350942799
>>> 2 + 3 * 4
14
2022-06-09 14:58:11.653907043
>>> (2 + 3) * 4
20
2022-06-09 15:00:14.692578713
>>> :i sqrt
type Floating :: * -> Constraint
class Fractional a => Floating a where
  ...
  sqrt :: a -> a
  ...
  	-- Defined in ‘GHC.Float’
2022-06-09 15:00:45.239492417
>>> sqrt (3 ^ 2 + 4 ^ 2)
5.0
2022-06-09 15:03:26.670753214
>>> sqrt (25 :: int)

<interactive>:5:7: error:
    • Could not deduce (Num int) arising from the literal ‘25’
      from the context: Floating a
        bound by the inferred type of it :: Floating a => a
        at <interactive>:5:1-16
      Possible fix:
        add (Num int) to the context of
          an expression type signature:
            forall int. int
    • In the first argument of ‘sqrt’, namely ‘(25 :: int)’
      In the expression: sqrt (25 :: int)
      In an equation for ‘it’: it = sqrt (25 :: int)
2022-06-09 15:08:20.093213577
>>> sqrt (25 :: double)

<interactive>:6:7: error:
    • Could not deduce (Num double) arising from the literal ‘25’
      from the context: Floating a
        bound by the inferred type of it :: Floating a => a
        at <interactive>:6:1-19
      Possible fix:
        add (Num double) to the context of
          an expression type signature:
            forall double. double
    • In the first argument of ‘sqrt’, namely ‘(25 :: double)’
      In the expression: sqrt (25 :: double)
      In an equation for ‘it’: it = sqrt (25 :: double)
2022-06-09 15:09:38.961254351
>>> sqrt (25 :: Double)
5.0
2022-06-09 15:10:12.732535502
>>> sqrt 25
5.0
2022-06-09 15:10:28.230951464
>>> hoge 25 :: int

<interactive>:9:1: error: Variable not in scope: hoge :: t0 -> int1
2022-06-09 15:13:25.295417127
>>> hoge 25 :: Int

<interactive>:10:1: error: Variable not in scope: hoge :: t0 -> Int
2022-06-09 15:15:24.64472839
>>> head [1,2,3]
1
2022-06-09 15:47:22.113051449
>>> head [3, 1, 4, 1, 5]
3
2022-06-09 15:47:48.589053114
>>> head []
*** Exception: Prelude.head: empty list
2022-06-09 15:50:25.089192948
>>> hoge = [3, 1, 4, 1, 5] :: Int

<interactive>:14:8: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[a0]’
    • In the expression: [3, 1, 4, 1, ....] :: Int
      In an equation for ‘hoge’: hoge = [3, 1, 4, ....] :: Int
2022-06-09 15:50:56.628639208
>>> hoge

<interactive>:15:1: error: Variable not in scope: hoge
2022-06-09 15:51:03.295042525
>>> hoge = [3, 1, 4, 1, 5] :: [Int]
2022-06-09 15:51:40.630128519
>>> hoge
[3,1,4,1,5]
2022-06-09 15:51:44.229342852
>>> head hoge
3
2022-06-09 15:51:57.369819605
>>> tail hoge
[1,4,1,5]
2022-06-09 15:52:07.611123055
>>> tail []
*** Exception: Prelude.tail: empty list
2022-06-09 15:52:43.521327216
>>> hoge last

<interactive>:21:1: error:
    • Couldn't match expected type: ([a0] -> a0) -> t
                  with actual type: [Int]
    • The function ‘hoge’ is applied to one value argument,
        but its type ‘[Int]’ has none
      In the expression: hoge last
      In an equation for ‘it’: it = hoge last
    • Relevant bindings include it :: t (bound at <interactive>:21:1)
2022-06-09 15:52:51.669447113
>>> hoge tail

<interactive>:22:1: error:
    • Couldn't match expected type: ([a0] -> [a0]) -> t
                  with actual type: [Int]
    • The function ‘hoge’ is applied to one value argument,
        but its type ‘[Int]’ has none
      In the expression: hoge tail
      In an equation for ‘it’: it = hoge tail
    • Relevant bindings include it :: t (bound at <interactive>:22:1)
2022-06-09 15:53:08.487920724
>>> last hoge
5
2022-06-09 15:53:18.816325364
>>> tail [1]
[]
2022-06-09 15:53:32.716649297
>>> hoge !! 0
3
2022-06-09 15:55:03.424709135
>>> hoge 2 !! hoge

<interactive>:26:1: error:
    • Couldn't match expected type: t0 -> [a]
                  with actual type: [Int]
    • The function ‘hoge’ is applied to one value argument,
        but its type ‘[Int]’ has none
      In the first argument of ‘(!!)’, namely ‘hoge 2’
      In the expression: hoge 2 !! hoge
    • Relevant bindings include it :: a (bound at <interactive>:26:1)

<interactive>:26:11: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[Int]’
    • In the second argument of ‘(!!)’, namely ‘hoge’
      In the expression: hoge 2 !! hoge
      In an equation for ‘it’: it = hoge 2 !! hoge
2022-06-09 15:55:28.213394982
>>> hoge 2 !! hoge

<interactive>:27:1: error:
    • Couldn't match expected type: t0 -> [a]
                  with actual type: [Int]
    • The function ‘hoge’ is applied to one value argument,
        but its type ‘[Int]’ has none
      In the first argument of ‘(!!)’, namely ‘hoge 2’
      In the expression: hoge 2 !! hoge
    • Relevant bindings include it :: a (bound at <interactive>:27:1)

<interactive>:27:11: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[Int]’
    • In the second argument of ‘(!!)’, namely ‘hoge’
      In the expression: hoge 2 !! hoge
      In an equation for ‘it’: it = hoge 2 !! hoge
2022-06-09 15:55:48.939046466
>>> hoge 2 !!

<interactive>:28:10: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-09 15:56:06.667477814
>>> hoge !! 2
4
2022-06-09 15:56:20.887679317
>>> take 3 hoge
[3,1,4]
2022-06-09 15:56:30.167445769
>>> dorop 3 hoge

<interactive>:31:1: error:
    • Variable not in scope: dorop :: t0 -> [Int] -> t
    • Perhaps you meant ‘drop’ (imported from Prelude)
2022-06-09 15:57:31.993040228
>>> drop 3 hoge
[1,5]
2022-06-09 15:57:41.038702466
>>> hoge 5

<interactive>:33:1: error:
    • Couldn't match expected type: t0 -> t
                  with actual type: [Int]
    • The function ‘hoge’ is applied to one value argument,
        but its type ‘[Int]’ has none
      In the expression: hoge 5
      In an equation for ‘it’: it = hoge 5
    • Relevant bindings include it :: t (bound at <interactive>:33:1)
2022-06-09 15:58:18.091766179
>>> hoge !! 5
*** Exception: Prelude.!!: index too large
2022-06-09 15:58:55.314945648
>>> take 10 hoge
[3,1,4,1,5]
2022-06-09 15:59:20.161071903
>>> drop 10 hoge
[]
2022-06-09 15:59:51.729614015
>>> length hoge
5
2022-06-09 16:01:49.57716578
>>> length []
0
2022-06-09 16:02:02.989372677
>>> sun hoge

<interactive>:39:1: error:
    • Variable not in scope: sun :: [Int] -> t
    • Perhaps you meant one of these:
        ‘sum’ (imported from Prelude), ‘sin’ (imported from Prelude)
2022-06-09 16:02:10.218818564
>>> sum hoge
14
2022-06-09 16:02:22.177542175
>>> product hoge
60
2022-06-09 16:02:34.548874766
>>> hoge ++ hoge
[3,1,4,1,5,3,1,4,1,5]
2022-06-09 16:04:47.751003908
>>> reverse hoge
[5,1,4,1,3]
2022-06-09 16:05:37.932137503
>>> lode src/first.ha

<interactive>:44:1: error:
    Variable not in scope: lode :: t0 -> a -> c

<interactive>:44:6: error: Variable not in scope: src

<interactive>:44:10: error: Variable not in scope: first :: b0 -> c

<interactive>:44:16: error: Variable not in scope: ha :: a -> b0
2022-06-09 16:08:20.640844233
>>> lode src/first.hs

<interactive>:45:1: error:
    Variable not in scope: lode :: t0 -> a -> c

<interactive>:45:6: error: Variable not in scope: src

<interactive>:45:10: error: Variable not in scope: first :: b0 -> c

<interactive>:45:16: error: Variable not in scope: hs :: a -> b0
2022-06-09 16:08:24.782848779
>>> :lode src/first.hs
unknown command ':lode'
use :? for help.
2022-06-09 16:08:37.053498979
>>> :e src/first.hs
catn: src/first.hs: openFile: does not exist (No such file or directory)
2022-06-09 16:08:59.854771284
>>> :load src/first.hs

<no location info>: error: can't find file: src/first.hs
Failed, no modules loaded.
2022-06-09 16:08:59.888414401
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x

<no location info>: error: can't find file: src/first.hs
Failed, no modules loaded.
2022-06-09 16:09:49.249620714
>>> :load src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:09:49.349248517
>>> double 3 + 3
9
2022-06-09 16:10:33.899298557
>>> double (3 + 3)
12
2022-06-09 16:11:11.935125063
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-09 16:14:37.144880338
>>> quadruple 2
8
2022-06-09 16:15:04.82194041
>>> quit

<interactive>:55:1: error:
    • Variable not in scope: quit
    • Perhaps you meant ‘quot’ (imported from Prelude)
2022-06-09 16:15:23.316269391
>>> git add .

<interactive>:56:10: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-09 16:15:35.279756936
>>> git add .

<interactive>:57:10: error:
    parse error (possibly incorrect indentation or mismatched brackets)
2022-06-09 16:16:34.092741725
>>> :quit
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kanonh/bprog2022/.ghci
2022-06-16 15:02:13.278194443
>>> take 3 [3,1,4,1,5]
[3,1,4]
2022-06-16 15:04:31.525520559
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
Ok, no modules loaded.
2022-06-16 15:12:20.301954156
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:12:20.388273589
>>> [1 of 1] Compiling First

<interactive>:4:4: error: parse error on input ‘of’
2022-06-16 15:13:01.614131013
>>> [1 of  1] Compiling First

<interactive>:5:4: error: parse error on input ‘of’
2022-06-16 15:14:04.143622707
>>> double

<interactive>:6:1: error:
    • No instance for (Show (Int -> Int)) arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-16 15:14:22.375604869
>>> take (double 2) [1,2,3,4,5]
[1,2,3,4]
2022-06-16 15:15:40.678149951
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:21:12.894434047
>>> factorial 3
6
2022-06-16 15:22:58.996038105
>>> factorial 4
24
2022-06-16 15:23:19.39915969
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
Ok, one module loaded.
2022-06-16 15:30:42.050897113
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs)(length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )

src/First.hs:13:14: error:
    • Couldn't match expected type ‘Int’ with actual type ‘[Int]’
    • In the expression: xs `div` length xs
      In an equation for ‘average’: average xs = xs `div` length xs
   |
13 | average xs = xs `div` length xs
   |              ^^^^^^^^^^^^^^^^^^

src/First.hs:13:23: error:
    • Couldn't match expected type ‘[Int]’ with actual type ‘Int’
    • In the second argument of ‘div’, namely ‘length xs’
      In the expression: xs `div` length xs
      In an equation for ‘average’: average xs = xs `div` length xs
   |
13 | average xs = xs `div` length xs
   |                       ^^^^^^^^^
Failed, no modules loaded.
2022-06-16 15:38:27.42153369
>>> average hoge

<interactive>:13:1: error:
    Variable not in scope: average :: t0 -> t

<interactive>:13:9: error: Variable not in scope: hoge
2022-06-16 15:38:47.454049121
>>> average [1,2,3,4,5]

<interactive>:14:1: error:
    Variable not in scope: average :: [a0] -> t
2022-06-16 15:39:05.103988082
>>> :e
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs)(length xs)
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-16 15:39:38.666735578
>>> average [1,2,3,4,5]
3
2022-06-16 15:39:42.938886869
>>> :t take 3 [1,2,3,4,5]
take 3 [1,2,3,4,5] :: Num a => [a]
2022-06-16 15:54:00.489686652
>>> init [1 .. 5]
[1,2,3,4]
2022-06-16 16:07:04.18286301
>>> myinit [1 .. 5]

<interactive>:19:1: error:
    • Variable not in scope: myinit :: [a0] -> t
    • Perhaps you meant ‘init’ (imported from Prelude)
2022-06-16 16:14:46.965297338
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kanonh/bprog2022/.ghci
2022-06-23 14:56:14.391489905
>>> :i Num
type Num :: * -> Constraint
class Num a where
  (+) :: a -> a -> a
  (-) :: a -> a -> a
  (*) :: a -> a -> a
  negate :: a -> a
  abs :: a -> a
  signum :: a -> a
  fromInteger :: Integer -> a
  {-# MINIMAL (+), (*), abs, signum, fromInteger, (negate | (-)) #-}
  	-- Defined in ‘GHC.Num’
instance Num NominalDiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.NominalDiffTime’
instance Num DiffTime
  -- Defined in ‘time-1.9.3:Data.Time.Clock.Internal.DiffTime’
instance Num Word -- Defined in ‘GHC.Num’
instance Num Integer -- Defined in ‘GHC.Num’
instance Num Int -- Defined in ‘GHC.Num’
instance Num Float -- Defined in ‘GHC.Float’
instance Num Double -- Defined in ‘GHC.Float’
2022-06-23 14:56:44.049073079
>>> 1 == 2
False
2022-06-23 15:06:16.612659838
>>> 1 <= 2
True
2022-06-23 15:06:28.576304558
>>> 1 < 1
False
2022-06-23 15:06:47.376752074
>>> 1 < 2
True
2022-06-23 15:07:05.574559804
>>> 1 >= 2
False
2022-06-23 15:07:19.309953508
>>> a > b

<interactive>:7:1: error: Variable not in scope: a

<interactive>:7:5: error: Variable not in scope: b
2022-06-23 15:07:49.709503861
>>> a >= b

<interactive>:8:1: error: Variable not in scope: a

<interactive>:8:6: error: Variable not in scope: b
2022-06-23 15:08:22.764830414
>>> 'a' < 'B'
False
2022-06-23 15:11:50.760212993
>>> 'ab' < 'b'

<interactive>:10:1: error:
    • Syntax error on 'ab'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'ab'
2022-06-23 15:12:59.500286318
>>> 1 /= 2
True
2022-06-23 15:16:35.834205095
>>> 1 /= 1
False
2022-06-23 15:16:58.211024186
>>> :i abs
type Num :: * -> Constraint
class Num a where
  ...
  abs :: a -> a
  ...
  	-- Defined in ‘GHC.Num’
2022-06-23 15:30:28.302152807
>>> abs

<interactive>:14:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-23 15:30:50.417298972
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kanonh/bprog2022/.ghci
2022-06-23 15:32:21.106647383
>>> abs

<interactive>:1:1: error:
    • No instance for (Show (Integer -> Integer))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-06-23 15:32:41.787944586
>>> abs (-234)
234
2022-06-23 15:34:47.317484414
>>> GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kanonh/bprog2022/.ghci
2022-06-30 14:56:19.037746224
>>> [ x ^ 2 | x <- [1 .. 5] ]
[1,4,9,16,25]
2022-06-30 15:00:29.301475136
>>> map (^2) [1..5]
[1,4,9,16,25]
2022-06-30 15:06:15.268873724
>>> [ x * 2 | x <- [1 .. 5] ]
[2,4,6,8,10]
2022-06-30 15:11:52.202461834
>>> [ x `div` 2  | x <- [1 .. 5] ]
[0,1,1,2,2]
2022-06-30 15:13:07.875694317
>>> [ x `divMod` 2  | x <- [1 .. 5] ]
[(0,1),(1,0),(1,1),(2,0),(2,1)]
2022-06-30 15:15:22.302145568
>>> [ (x, y) | x <- "a,b,c", y <- [4,5]]
[('a',4),('a',5),(',',4),(',',5),('b',4),('b',5),(',',4),(',',5),('c',4),('c',5)]
2022-06-30 15:20:43.386083182
>>> [ (x, y) | x <- "abc", y <- [4,5]]
[('a',4),('a',5),('b',4),('b',5),('c',4),('c',5)]
2022-06-30 15:21:23.892002132
>>> [ (x, y) | y <- [4,5], x <- "abc" ]
[('a',4),('b',4),('c',4),('a',5),('b',5),('c',5)]
2022-06-30 15:22:03.620256797
>>> ls

<interactive>:9:1: error: Variable not in scope: ls
2022-06-30 15:27:37.785767071
>>> load

<interactive>:10:1: error: Variable not in scope: load
2022-06-30 15:28:55.771008346
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs)(length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs ]
Ok, no modules loaded.
2022-06-30 15:29:36.415217735
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:29:36.500730438
>>> myconcat[[1,2,3],[4,5],[6,7,8,9]]
[1,2,3,4,5,6,7,8,9]
2022-06-30 15:47:38.084657115
>>> [ 1 | _ <- [1 .. 5] ]
[1,1,1,1,1]
2022-06-30 15:48:17.554725719
>>> :e src/First.hs
   1  module First where
   2  
   3  double :: Int -> Int
   4  double x = x + x
   5  
   6  quadruple :: Int -> Int
   7  quadruple x = double (double x)
   8  
   9  factorial :: Integer -> Integer
  10  factorial n = product [1 .. n]
  11  
  12  average :: [Int] -> Int
  13  average xs = sum xs `div` length xs
  14  
  15  ave :: [Int] -> Int
  16  ave xs = div (sum xs)(length xs)
  17  
  18  myinit :: [a] -> [a]
  19  myinit (x:[]) = []
  20  myinit (x:xs) = x : (init xs)
  21  
  22  myconcat :: [[a]] -> [a]
  23  myconcat xss = [ x | xs <- xss, x <- xs ]
  24  
  25  mylength :: [a] -> Int
  26  mylength xs = sum [ 1 | _ <- xs ]
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:50:26.963050321
>>> :l src/First.hs
[1 of 1] Compiling First            ( src/First.hs, interpreted )
Ok, one module loaded.
2022-06-30 15:50:27.065976492
>>> mylength ['a' .. 'z']
26
2022-06-30 15:51:03.40486264
>>> ['a' .. 'z']
"abcdefghijklmnopqrstuvwxyz"
2022-06-30 15:51:20.294238135
>>> ['あ' .. 'ん']
"\12354\12355\12356\12357\12358\12359\12360\12361\12362\12363\12364\12365\12366\12367\12368\12369\12370\12371\12372\12373\12374\12375\12376\12377\12378\12379\12380\12381\12382\12383\12384\12385\12386\12387\12388\12389\12390\12391\12392\12393\12394\12395\12396\12397\12398\12399\12400\12401\12402\12403\12404\12405\12406\12407\12408\12409\12410\12411\12412\12413\12414\12415\12416\12417\12418\12419\12420\12421\12422\12423\12424\12425\12426\12427\12428\12429\12430\12431\12432\12433\12434\12435"
2022-06-30 15:51:36.31026708
>>> putStrLn it
あぃいぅうぇえぉおかがきぎくぐけげこごさざしじすずせぜそぞただちぢっつづてでとどなにぬねのはばぱひびぴふぶぷへべぺほぼぽまみむめもゃやゅゆょよらりるれろゎわゐゑをん
2022-06-30 15:52:57.201037928
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kanonh/bprog2022/.ghci
2022-07-07 16:05:35.816476523
>>> :e scr/Caesar.hs
catn: scr/Caesar.hs: openFile: does not exist (No such file or directory)
2022-07-07 16:06:08.461662114
>>> :l scr/Caesar.hs

<no location info>: error: can't find file: scr/Caesar.hs
Failed, no modules loaded.
2022-07-07 16:06:08.552883047
>>> :e scr/Caesar.hs
catn: scr/Caesar.hs: openFile: does not exist (No such file or directory)
2022-07-07 16:07:25.085709898
>>> :l scr/Caesar.hs

<no location info>: error: can't find file: scr/Caesar.hs
Failed, no modules loaded.
2022-07-07 16:07:25.184737717
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Date.Char

<no location info>: error: can't find file: scr/Caesar.hs
Failed, no modules loaded.
2022-07-07 16:07:55.887563745
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:3:1: error:
    Could not find module ‘Date.Char’
    Perhaps you meant Data.Char (from base-4.15.1.0)
    Use -v (or `:set -v` in ghci) to see a list of the files searched for.
  |
3 | import Date.Char
  | ^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-07 16:07:55.991929257
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:08:19.493231037
>>> :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-07 16:08:19.565733382
>>> :q
Leaving GHCi.
GHCi, version 9.0.2: https://www.haskell.org/ghc/  :? for help
Loaded GHCi configuration from /home/kanonh/bprog2022/.ghci
2022-07-14 15:11:48.85264756
>>> :e src/Caeser.hs
catn: src/Caeser.hs: openFile: does not exist (No such file or directory)
2022-07-14 15:12:25.269381584
>>>  :l src/Caeser.hs

<no location info>: error: can't find file: src/Caeser.hs
Failed, no modules loaded.
2022-07-14 15:12:25.308568573
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c

<no location info>: error: can't find file: src/Caeser.hs
Failed, no modules loaded.
2022-07-14 15:12:46.390401388
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:12:46.452183659
>>> let2int 'a'
97
2022-07-14 15:13:06.370332834
>>> let2int 'z'
122
2022-07-14 15:13:20.693506867
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:15:13.868811587
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:15:13.921269232
>>> let2int 'a'
0
2022-07-14 15:15:28.273760694
>>> let2int 'z'
25
2022-07-14 15:15:33.796740622
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:21:40.961484709
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:21:41.020880016
>>> int2let 0
'a'
2022-07-14 15:22:00.187827074
>>> int2let 25
'z'
2022-07-14 15:22:05.516695994
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = ((let2int c + n) 'mod' 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:36: error:
    • Syntax error on 'mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'mod'
   |
13 |     | isLower c = ((let2int c + n) 'mod' 26)
   |                                    ^^^^^
Failed, no modules loaded.
2022-07-14 15:27:34.981359342
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:36: error:
    • Syntax error on 'mod'
      Perhaps you intended to use TemplateHaskell or TemplateHaskellQuotes
    • In the Template Haskell quotation 'mod'
   |
13 |     | isLower c = ((let2int c + n) 'mod' 26)
   |                                    ^^^^^
Failed, no modules loaded.
2022-07-14 15:27:35.040327709
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = ((let2int c + n) `mod`` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:41: error: parse error on input ‘`’
   |
13 |     | isLower c = ((let2int c + n) `mod`` 26)
   |                                         ^
Failed, no modules loaded.
2022-07-14 15:28:09.062067462
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:41: error: parse error on input ‘`’
   |
13 |     | isLower c = ((let2int c + n) `mod`` 26)
   |                                         ^
Failed, no modules loaded.
2022-07-14 15:28:09.160013829
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = ((let2int c + n) `mod` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:20: error:
    • Couldn't match expected type ‘Char’ with actual type ‘Int’
    • In the expression: (let2int c + n) `mod` 26
      In an equation for ‘shift’:
          shift n c
            | isLower c = ((let2int c + n) `mod` 26)
            | otherwise = c
   |
13 |     | isLower c = ((let2int c + n) `mod` 26)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 15:28:26.087556399
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:20: error:
    • Couldn't match expected type ‘Char’ with actual type ‘Int’
    • In the expression: (let2int c + n) `mod` 26
      In an equation for ‘shift’:
          shift n c
            | isLower c = ((let2int c + n) `mod` 26)
            | otherwise = c
   |
13 |     | isLower c = ((let2int c + n) `mod` 26)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 15:28:26.118307947
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = ((let2int c + n) `mod` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:20: error:
    • Couldn't match expected type ‘Char’ with actual type ‘Int’
    • In the expression: (let2int c + n) `mod` 26
      In an equation for ‘shift’:
          shift n c
            | isLower c = ((let2int c + n) `mod` 26)
            | otherwise = c
   |
13 |     | isLower c = ((let2int c + n) `mod` 26)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 15:30:43.671829129
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:13:20: error:
    • Couldn't match expected type ‘Char’ with actual type ‘Int’
    • In the expression: (let2int c + n) `mod` 26
      In an equation for ‘shift’:
          shift n c
            | isLower c = ((let2int c + n) `mod` 26)
            | otherwise = c
   |
13 |     | isLower c = ((let2int c + n) `mod` 26)
   |                    ^^^^^^^^^^^^^^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 15:30:43.768992435
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:31:28.542902081
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:31:28.641345806
>>> shift 3 'a'
'd'
2022-07-14 15:32:51.197166866
>>> shift (-3) 'd'
'a'
2022-07-14 15:33:10.732244744
>>> shift 3 'z'
'c'
2022-07-14 15:33:18.565747429
>>> shift 3 ' '
' '
2022-07-14 15:33:26.099462726
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:35:58.239350304
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:35:58.337681991
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:36:24.655301459
>>> encode (-3) "haskell is fun"
"exphbii fp crk"
2022-07-14 15:37:13.521252501
>>> it
"exphbii fp crk"
2022-07-14 15:48:17.09943857
>>> encode (-3) "it"
"fq"
2022-07-14 15:48:34.132588458
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:48:55.177259746
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:48:56.352455319
>>> it
"kdvnhoo lv ixq"
2022-07-14 15:49:00.73528532
>>> encode 3 "haskell is fun"
"kdvnhoo lv ixq"
2022-07-14 15:49:02.817409982
>>> encode (-3) it
"haskell is fun"
2022-07-14 15:49:14.934626624
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:59:17.727343982
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 15:59:17.824619826
>>> length table
26
2022-07-14 16:05:16.742925473
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = n / m * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:26:15: error:
    • Couldn't match expected type ‘Float’ with actual type ‘Int’
    • In the expression: n / m * 100
      In an equation for ‘percent’: percent n m = n / m * 100
   |
26 | percent n m = n / m * 100
   |               ^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 16:06:52.740841249
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )

src/Caesar.hs:26:15: error:
    • Couldn't match expected type ‘Float’ with actual type ‘Int’
    • In the expression: n / m * 100
      In an equation for ‘percent’: percent n m = n / m * 100
   |
26 | percent n m = n / m * 100
   |               ^^^^^^^^^^^
Failed, no modules loaded.
2022-07-14 16:06:52.838532875
>>> :e src/Caesar.hs
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:08:47.520305301
>>>  :l src/Caesar.hs
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:08:47.61906544
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
Ok, one module loaded.
2022-07-14 16:09:03.027230609
>>> percent 5 15
33.333336
2022-07-14 16:09:28.473976695
>>> 
2022-07-14 16:12:41.666471701
>>> :e
   1  module Caesar where
   2  
   3  import Data.Char
   4  
   5  let2int :: Char -> Int
   6  let2int c = ord c - ord 'a'
   7  
   8  int2let :: Int -> Char
   9  int2let n = chr (ord 'a' + n)
  10  
  11  shift :: Int -> (Char -> Char)
  12  shift n c
  13      | isLower c = int2let ((let2int c + n) `mod` 26)
  14      | otherwise = c
  15  
  16  encode :: Int -> (String -> String)
  17  encode n xs = [ shift n x | x <- xs]
  18  
  19  table :: [Float]
  20  table = [ 8.1, 1.5, 2.8, 4.2, 12.7, 2.2, 2.0, 6.1, 7.0
  21          , 0.2, 0.8, 4.0, 2.4,  6.7, 7.5, 1.9, 0.1, 6.0
  22          , 6.3, 9.0, 2.8, 1.0,  2.4, 0.2, 2.0, 0.1
  23          ]
  24  
  25  percent :: Int -> Int -> Float
  26  percent n m = (fromIntegral n / fromIntegral m) * 100
  27  
  28  count :: Char -> (String -> Int)
  29  count x xs = length [ x' | x' <- xs, x == x']
[1 of 1] Compiling Caesar           ( src/Caesar.hs, interpreted )
Ok, one module loaded.
2022-07-14 16:14:22.24361544
>>> count 's'

<interactive>:51:1: error:
    • No instance for (Show (String -> Int))
        arising from a use of ‘print’
        (maybe you haven't applied a function to enough arguments?)
    • In a stmt of an interactive GHCi command: print it
2022-07-14 16:14:35.684289874
>>> count 's' "Mississippi"
4
2022-07-14 16:15:31.92557387
>>> q

<interactive>:53:1: error: Variable not in scope: q
2022-07-14 16:15:44.77472828
>>> :q
Leaving GHCi.
